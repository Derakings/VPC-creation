#!/bin/bash
# VPC Controller - Complete Implementation
# Stage 4 - DevOps VPC Project

# ==========================================
# Configuration & Logging Setup
# ==========================================
LOG_FILE="/var/log/vpcctl.log"
STATE_DIR="/var/lib/vpcctl"
PEERING_FILE="$STATE_DIR/peerings.conf"

# Ensure directories exist
mkdir -p "$STATE_DIR" 2>/dev/null
touch "$LOG_FILE" 2>/dev/null

# Logging functions with timestamps
log_info() { 
    local msg="[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
    echo -e "\033[0;34m$msg\033[0m" 
    echo "$msg" >> "$LOG_FILE"
}

log_success() { 
    local msg="[SUCCESS] $(date '+%Y-%m-%d %H:%M:%S') $1"
    echo -e "\033[0;32m✅ $1\033[0m"
    echo "$msg" >> "$LOG_FILE"
}

log_error() { 
    local msg="[ERROR] $(date '+%Y-%m-%d %H:%M:%S') $1"
    echo -e "\033[0;31m❌ $1\033[0m" >&2
    echo "$msg" >> "$LOG_FILE"
}

log_warning() {
    local msg="[WARNING] $(date '+%Y-%m-%d %H:%M:%S') $1"
    echo -e "\033[0;33m⚠️  $1\033[0m"
    echo "$msg" >> "$LOG_FILE"
}

# Check root privileges
if [ "$EUID" -ne 0 ]; then
    log_error "Please run with sudo"
    exit 1
fi

# ==========================================
# Helper Functions
# ==========================================

vpc_exists() {
    local vpc_name=$1
    ip link show "vpc-${vpc_name}-br" &>/dev/null
}

namespace_exists() {
    local namespace=$1
    ip netns list 2>/dev/null | grep -q "^${namespace}"
}

get_vpc_state() {
    local vpc_name=$1
    local state_file="$STATE_DIR/${vpc_name}.state"
    
    if [ -f "$state_file" ]; then
        cat "$state_file"
    fi
}

save_vpc_state() {
    local vpc_name=$1
    local cidr=$2
    local state_file="$STATE_DIR/${vpc_name}.state"
    
    echo "VPC_NAME=$vpc_name" > "$state_file"
    echo "CIDR=$cidr" >> "$state_file"
    echo "CREATED=$(date '+%Y-%m-%d %H:%M:%S')" >> "$state_file"
}

# ==========================================
# COMMAND: create-vpc
# ==========================================
if [ "$1" = "create-vpc" ]; then
    VPC_NAME=$2
    CIDR=$3
    
    if [ -z "$VPC_NAME" ] || [ -z "$CIDR" ]; then
        log_error "Usage: vpcctl create-vpc <name> <cidr>"
        exit 1
    fi
    
    BRIDGE="vpc-${VPC_NAME}-br"
    
    # Idempotency check
    if vpc_exists "$VPC_NAME"; then
        log_warning "VPC '$VPC_NAME' already exists. Skipping creation."
        exit 0
    fi
    
    log_info "Creating VPC: $VPC_NAME ($CIDR)"
    
    # Enable bridge forwarding
    echo 1 > /proc/sys/net/bridge/bridge-nf-call-iptables 2>/dev/null || true
    echo 1 > /proc/sys/net/ipv4/ip_forward
    
    # Create bridge
    if ! ip link add name "$BRIDGE" type bridge 2>/dev/null; then
        log_error "Failed to create bridge $BRIDGE"
        exit 1
    fi
    
    ip link set "$BRIDGE" up
    
    # Assign IP to bridge (gateway)
    BRIDGE_IP="${CIDR%.*}.1/${CIDR##*/}"
    ip addr add "$BRIDGE_IP" dev "$BRIDGE"
    
    # Save state
    save_vpc_state "$VPC_NAME" "$CIDR"
    
    log_success "VPC '$VPC_NAME' created!"
    log_info "Bridge: $BRIDGE"
    log_info "Gateway: $BRIDGE_IP"
    log_info "CIDR: $CIDR"

# ==========================================
# COMMAND: add-subnet
# ==========================================
elif [ "$1" = "add-subnet" ]; then
    VPC_NAME=$2
    SUBNET_NAME=$3
    SUBNET_CIDR=$4
    
    if [ -z "$VPC_NAME" ] || [ -z "$SUBNET_NAME" ] || [ -z "$SUBNET_CIDR" ]; then
        log_error "Usage: vpcctl add-subnet <vpc-name> <subnet-name> <cidr>"
        exit 1
    fi
    
    BRIDGE="vpc-${VPC_NAME}-br"
    NAMESPACE="vpc-${VPC_NAME}-${SUBNET_NAME}"
    VETH_HOST="veth-${SUBNET_NAME}-h"
    VETH_NS="veth-${SUBNET_NAME}-n"
    
    # Check if VPC exists
    if ! vpc_exists "$VPC_NAME"; then
        log_error "VPC '$VPC_NAME' does not exist. Create it first."
        exit 1
    fi
    
    # Idempotency check
    if namespace_exists "$NAMESPACE"; then
        log_warning "Subnet '$SUBNET_NAME' already exists in VPC '$VPC_NAME'. Skipping."
        exit 0
    fi
    
    log_info "Adding subnet: $SUBNET_NAME to VPC $VPC_NAME"
    
    # Enable bridge forwarding
    echo 1 > /proc/sys/net/bridge/bridge-nf-call-iptables 2>/dev/null || true
    echo 1 > /proc/sys/net/ipv4/ip_forward
    
    # Create namespace
    ip netns add "$NAMESPACE"
    
    # Delete old veth if exists
    ip link del "$VETH_HOST" 2>/dev/null || true

    # Create veth pair
    ip link add "$VETH_HOST" type veth peer name "$VETH_NS"
    
    # Move one end to namespace
    ip link set "$VETH_NS" netns "$NAMESPACE"
    
    # Connect to bridge
    ip link set "$VETH_HOST" master "$BRIDGE"
    ip link set "$VETH_HOST" up
    
    # Configure namespace
    ip netns exec "$NAMESPACE" ip link set lo up
    ip netns exec "$NAMESPACE" ip link set "$VETH_NS" up
    
    # Assign IP
    NS_IP="${SUBNET_CIDR%.*}.2/${SUBNET_CIDR##*/}"
    ip netns exec "$NAMESPACE" ip addr add "$NS_IP" dev "$VETH_NS"
    
    # Add default route
    GATEWAY="${SUBNET_CIDR%.*}.1"
    ip addr add "${GATEWAY}/${SUBNET_CIDR##*/}" dev "$BRIDGE" 2>/dev/null || true
    ip netns exec "$NAMESPACE" ip route add default via "$GATEWAY"
    
    log_success "Subnet '$SUBNET_NAME' created!"
    log_info "Namespace: $NAMESPACE"
    log_info "IP: $NS_IP"
    log_info "Gateway: $GATEWAY"

# ==========================================
# COMMAND: enable-nat
# ==========================================
elif [ "$1" = "enable-nat" ]; then
    VPC_NAME=$2
    SUBNET_CIDR=$3
    EXT_IF=$4
    
    if [ -z "$VPC_NAME" ] || [ -z "$SUBNET_CIDR" ]; then
        log_error "Usage: vpcctl enable-nat <vpc-name> <subnet-cidr> [interface]"
        exit 1
    fi
    
    # Auto-detect default interface if not specified
    if [ -z "$EXT_IF" ]; then
        EXT_IF=$(ip route | grep default | awk '{print $5}' | head -n1)
        log_info "Auto-detected external interface: $EXT_IF"
    fi
    
    log_info "Enabling NAT for $SUBNET_CIDR via $EXT_IF"
    
    # Enable IP forwarding
    echo 1 > /proc/sys/net/ipv4/ip_forward
    
    # Check if rule already exists (idempotency)
    if ! iptables -t nat -C POSTROUTING -s "$SUBNET_CIDR" -o "$EXT_IF" -j MASQUERADE 2>/dev/null; then
        iptables -t nat -A POSTROUTING -s "$SUBNET_CIDR" -o "$EXT_IF" -j MASQUERADE
        log_info "NAT rule added"
    else
        log_warning "NAT rule already exists"
    fi
    
    if ! iptables -C FORWARD -s "$SUBNET_CIDR" -j ACCEPT 2>/dev/null; then
        iptables -A FORWARD -s "$SUBNET_CIDR" -j ACCEPT
    fi
    
    if ! iptables -C FORWARD -d "$SUBNET_CIDR" -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null; then
        iptables -A FORWARD -d "$SUBNET_CIDR" -m state --state RELATED,ESTABLISHED -j ACCEPT
    fi
    
    log_success "NAT enabled for $SUBNET_CIDR"

# ==========================================
# COMMAND: apply-security-group
# ==========================================
elif [ "$1" = "apply-security-group" ]; then
    NAMESPACE=$2
    POLICY_FILE=$3
    
    if [ -z "$NAMESPACE" ] || [ -z "$POLICY_FILE" ]; then
        log_error "Usage: vpcctl apply-security-group <namespace> <policy-file.json>"
        exit 1
    fi
    
    if [ ! -f "$POLICY_FILE" ]; then
        log_error "Policy file not found: $POLICY_FILE"
        exit 1
    fi
    
    if ! namespace_exists "$NAMESPACE"; then
        log_error "Namespace '$NAMESPACE' does not exist"
        exit 1
    fi
    
    log_info "Applying security group rules to $NAMESPACE"
    
    # Set default policy to ACCEPT first
    ip netns exec "$NAMESPACE" iptables -P INPUT ACCEPT 2>/dev/null || true
    
    # Parse and apply each rule
    jq -c '.ingress[]' "$POLICY_FILE" 2>/dev/null | while IFS= read -r line; do
        port=$(echo "$line" | jq -r '.port')
        protocol=$(echo "$line" | jq -r '.protocol')
        action=$(echo "$line" | jq -r '.action')
        
        if [ "$action" = "deny" ]; then
            ip netns exec "$NAMESPACE" iptables -A INPUT -p "$protocol" --dport "$port" -j DROP
            log_info "DENY: $protocol port $port"
        elif [ "$action" = "allow" ]; then
            ip netns exec "$NAMESPACE" iptables -A INPUT -p "$protocol" --dport "$port" -j ACCEPT
            log_info "ALLOW: $protocol port $port"
        fi
    done
    
    log_success "Security group applied to $NAMESPACE"

# ==========================================
# COMMAND: create-peering
# ==========================================
elif [ "$1" = "create-peering" ]; then
    VPC1=$2
    VPC2=$3
    
    if [ -z "$VPC1" ] || [ -z "$VPC2" ]; then
        log_error "Usage: vpcctl create-peering <vpc1> <vpc2>"
        exit 1
    fi
    
    if ! vpc_exists "$VPC1"; then
        log_error "VPC '$VPC1' does not exist"
        exit 1
    fi
    
    if ! vpc_exists "$VPC2"; then
        log_error "VPC '$VPC2' does not exist"
        exit 1
    fi
    
    # Check if peering already exists
    if grep -q "${VPC1}<->${VPC2}" "$PEERING_FILE" 2>/dev/null || grep -q "${VPC2}<->${VPC1}" "$PEERING_FILE" 2>/dev/null; then
        log_warning "Peering already exists between $VPC1 and $VPC2"
        exit 0
    fi
    
    log_info "Creating peering connection: $VPC1 <-> $VPC2"
    
    BRIDGE1="vpc-${VPC1}-br"
    BRIDGE2="vpc-${VPC2}-br"
    VETH1="peer-${VPC1}-${VPC2}"
    VETH2="peer-${VPC2}-${VPC1}"
    
    # Create veth pair between bridges
    ip link add "$VETH1" type veth peer name "$VETH2"
    
    # Attach to bridges
    ip link set "$VETH1" master "$BRIDGE1"
    ip link set "$VETH2" master "$BRIDGE2"
    
    # Bring up interfaces
    ip link set "$VETH1" up
    ip link set "$VETH2" up
    
    # Get CIDRs from state files
    VPC1_CIDR=$(grep "CIDR=" "$STATE_DIR/${VPC1}.state" | cut -d= -f2)
    VPC2_CIDR=$(grep "CIDR=" "$STATE_DIR/${VPC2}.state" | cut -d= -f2)
    
    # Add routes to all namespaces in each VPC
    for ns in $(ip netns list | grep "vpc-${VPC1}-" | awk '{print $1}'); do
        ip netns exec "$ns" ip route add "$VPC2_CIDR" via "${VPC1_CIDR%.*}.1" 2>/dev/null || true
    done
    
    for ns in $(ip netns list | grep "vpc-${VPC2}-" | awk '{print $1}'); do
        ip netns exec "$ns" ip route add "$VPC1_CIDR" via "${VPC2_CIDR%.*}.1" 2>/dev/null || true
    done
    
    # Save peering state
    echo "${VPC1}<->${VPC2}|${VETH1}|${VETH2}" >> "$PEERING_FILE"
    
    log_success "Peering created between $VPC1 and $VPC2"
    log_info "Bridge-to-bridge connection established"

# ==========================================
# COMMAND: delete-peering
# ==========================================
elif [ "$1" = "delete-peering" ]; then
    VPC1=$2
    VPC2=$3
    
    if [ -z "$VPC1" ] || [ -z "$VPC2" ]; then
        log_error "Usage: vpcctl delete-peering <vpc1> <vpc2>"
        exit 1
    fi
    
    log_info "Deleting peering connection: $VPC1 <-> $VPC2"
    
    # Find and delete veth pair
    VETH1="peer-${VPC1}-${VPC2}"
    VETH2="peer-${VPC2}-${VPC1}"
    
    ip link del "$VETH1" 2>/dev/null || ip link del "$VETH2" 2>/dev/null || true
    
    # Remove from state file
    if [ -f "$PEERING_FILE" ]; then
        sed -i "/${VPC1}<->${VPC2}/d" "$PEERING_FILE"
        sed -i "/${VPC2}<->${VPC1}/d" "$PEERING_FILE"
    fi
    
    log_success "Peering deleted between $VPC1 and $VPC2"

# ==========================================
# COMMAND: list-peering
# ==========================================
elif [ "$1" = "list-peering" ]; then
    echo "Active VPC Peerings:"
    if [ -f "$PEERING_FILE" ] && [ -s "$PEERING_FILE" ]; then
        while IFS='|' read -r connection veth1 veth2; do
            echo "  $connection"
        done < "$PEERING_FILE"
    else
        echo "  (none)"
    fi

# ==========================================
# COMMAND: describe
# ==========================================
elif [ "$1" = "describe" ]; then
    VPC_NAME=$2
    
    if [ -z "$VPC_NAME" ]; then
        log_error "Usage: vpcctl describe <vpc-name>"
        exit 1
    fi
    
    if ! vpc_exists "$VPC_NAME"; then
        log_error "VPC '$VPC_NAME' does not exist"
        exit 1
    fi
    
    echo "=========================================="
    echo "VPC: $VPC_NAME"
    echo "=========================================="
    
    # Show state
    if [ -f "$STATE_DIR/${VPC_NAME}.state" ]; then
        cat "$STATE_DIR/${VPC_NAME}.state"
        echo ""
    fi
    
    # Show bridge
    BRIDGE="vpc-${VPC_NAME}-br"
    echo "Bridge: $BRIDGE"
    ip addr show "$BRIDGE" 2>/dev/null | grep inet
    echo ""
    
    # Show subnets
    echo "Subnets/Namespaces:"
    for ns in $(ip netns list | grep "vpc-${VPC_NAME}-" | awk '{print $1}'); do
        echo "  - $ns"
        ip netns exec "$ns" ip addr show 2>/dev/null | grep "inet " | awk '{print "    IP: " $2}'
    done

# ==========================================
# COMMAND: start-server
# ==========================================
elif [ "$1" = "start-server" ]; then
    NAMESPACE=$2
    PORT=${3:-8080}
    
    if [ -z "$NAMESPACE" ]; then
        log_error "Usage: vpcctl start-server <namespace> [port]"
        exit 1
    fi
    
    if ! namespace_exists "$NAMESPACE"; then
        log_error "Namespace '$NAMESPACE' does not exist"
        exit 1
    fi
    
    log_info "Starting web server in $NAMESPACE on port $PORT"
    
    # Create web directory
    WEB_DIR="/tmp/vpc-web-$NAMESPACE"
    mkdir -p "$WEB_DIR"
    echo "<h1>Hello from $NAMESPACE</h1><p>Server is running on port $PORT!</p><p>Time: $(date)</p>" > "$WEB_DIR/index.html"
    
    # Start server
    ip netns exec "$NAMESPACE" bash -c "cd $WEB_DIR && nohup python3 -m http.server $PORT &>/dev/null &"
    
    sleep 1
    log_success "Web server started on port $PORT in $NAMESPACE"

# ==========================================
# COMMAND: stop-server
# ==========================================
elif [ "$1" = "stop-server" ]; then
    NAMESPACE=$2
    
    if [ -z "$NAMESPACE" ]; then
        log_error "Usage: vpcctl stop-server <namespace>"
        exit 1
    fi
    
    log_info "Stopping web server in $NAMESPACE"
    
    ip netns exec "$NAMESPACE" pkill -f "http.server" 2>/dev/null || true
    rm -rf "/tmp/vpc-web-$NAMESPACE"
    
    log_success "Web server stopped in $NAMESPACE"

# ==========================================
# COMMAND: delete-vpc
# ==========================================
elif [ "$1" = "delete-vpc" ]; then
    VPC_NAME=$2
    
    if [ -z "$VPC_NAME" ]; then
        log_error "Usage: vpcctl delete-vpc <name>"
        exit 1
    fi
    
    BRIDGE="vpc-${VPC_NAME}-br"
    
    log_info "Deleting VPC: $VPC_NAME"
    
    # Stop all servers first
    for ns in $(ip netns list | grep "vpc-${VPC_NAME}-" | awk '{print $1}'); do
        ip netns exec "$ns" pkill -f "http.server" 2>/dev/null || true
        rm -rf "/tmp/vpc-web-$ns" 2>/dev/null || true
    done
    
    # Delete peerings involving this VPC
    if [ -f "$PEERING_FILE" ]; then
        while IFS='|' read -r connection veth1 veth2; do
            if echo "$connection" | grep -q "$VPC_NAME"; then
                ip link del "$veth1" 2>/dev/null || true
                log_info "Deleted peering: $connection"
            fi
        done < "$PEERING_FILE"
        sed -i "/${VPC_NAME}/d" "$PEERING_FILE"
    fi
    
    # Delete all namespaces more robustly
    ip netns list 2>/dev/null | awk '{print $1}' | grep "^vpc-${VPC_NAME}-" | while read -r ns; do
        log_info "Deleting namespace: $ns"
        ip netns del "$ns" 2>/dev/null || true
    done
    
    # Delete bridge
    if ip link show "$BRIDGE" &>/dev/null; then
        ip link set "$BRIDGE" down 2>/dev/null
        ip link delete "$BRIDGE" 2>/dev/null
        log_info "Bridge deleted: $BRIDGE"
    fi
    
    # Remove state file
    rm -f "$STATE_DIR/${VPC_NAME}.state"
    
    # Clean up iptables rules
    iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE 2>/dev/null || true
    
    log_success "VPC '$VPC_NAME' deleted!"

# ==========================================
# COMMAND: list
# ==========================================
elif [ "$1" = "list" ]; then
    echo "=========================================="
    echo "VPC Resources"
    echo "=========================================="
    echo ""
    echo "VPC Namespaces:"
    ip netns list | grep "^vpc-" || echo "  (none)"
    echo ""
    echo "VPC Bridges:"
    ip link show type bridge | grep "vpc-" | awk '{print "  " $2}' | tr -d ':' || echo "  (none)"
    echo ""
    echo "Active Peerings:"
    if [ -f "$PEERING_FILE" ] && [ -s "$PEERING_FILE" ]; then
        while IFS='|' read -r connection veth1 veth2; do
            echo "  $connection"
        done < "$PEERING_FILE"
    else
        echo "  (none)"
    fi

# ==========================================
# COMMAND: logs
# ==========================================
elif [ "$1" = "logs" ]; then
    LINES=${2:-50}
    echo "=========================================="
    echo "Recent VPC Activity Logs (last $LINES lines)"
    echo "=========================================="
    tail -n "$LINES" "$LOG_FILE" 2>/dev/null || echo "No logs found"

# ==========================================
# COMMAND: help or no command
# ==========================================
else
    cat << 'HELP'
========================================
vpcctl - VPC Controller
Stage 4 DevOps Project
========================================

USAGE:
  sudo ./vpcctl <command> [options]

COMMANDS:

VPC Management:
  create-vpc <name> <cidr>
      Create a new VPC with specified CIDR
      Example: sudo ./vpcctl create-vpc myvpc 10.0.0.0/16

  delete-vpc <name>
      Delete a VPC and all its resources
      Example: sudo ./vpcctl delete-vpc myvpc

  describe <vpc-name>
      Show detailed information about a VPC
      Example: sudo ./vpcctl describe myvpc

  list
      List all VPCs, namespaces, and peerings

Subnet Management:
  add-subnet <vpc-name> <subnet-name> <cidr>
      Add a subnet to a VPC
      Example: sudo ./vpcctl add-subnet myvpc public 10.0.1.0/24

  enable-nat <vpc-name> <subnet-cidr> [interface]
      Enable NAT for a subnet (default interface: eth0)
      Example: sudo ./vpcctl enable-nat myvpc 10.0.1.0/24

VPC Peering:
  create-peering <vpc1> <vpc2>
      Create a peering connection between two VPCs
      Example: sudo ./vpcctl create-peering vpc1 vpc2

  delete-peering <vpc1> <vpc2>
      Delete a peering connection
      Example: sudo ./vpcctl delete-peering vpc1 vpc2

  list-peering
      List all active peering connections

Security Groups:
  apply-security-group <namespace> <policy-file.json>
      Apply firewall rules from JSON policy
      Example: sudo ./vpcctl apply-security-group vpc-myvpc-public security-groups.json

Application Management:
  start-server <namespace> [port]
      Start a web server in a namespace (default port: 8080)
      Example: sudo ./vpcctl start-server vpc-myvpc-public 8080

  stop-server <namespace>
      Stop web server in a namespace
      Example: sudo ./vpcctl stop-server vpc-myvpc-public

Logging:
  logs [lines]
      View recent activity logs (default: 50 lines)
      Example: sudo ./vpcctl logs 100

========================================
HELP
fi
